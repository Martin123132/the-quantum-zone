MBT Simulation Code Archive
1. MBT Electron Shell Transitions (No Core)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D

# --- MBT Simulation Parameters ---
num_particles = 20
num_shells = 3
shell_radii = [3 * (i + 1) for i in range(num_shells)]
dt = 0.05
steps = 500
ambient_energy_chance = 0.02
energy_boost = 0.5
damping_factor = 0.98

# --- Initial Particle Positions ---
positions = np.random.randn(num_particles, 3)
positions /= np.linalg.norm(positions, axis=1).reshape(-1, 1)
scaling_factors = np.random.choice(shell_radii, num_particles).reshape(-1, 1)
positions *= scaling_factors

# --- Initial Velocities ---
velocities = np.random.randn(num_particles, 3) * 0.1

# --- MBT Curvature Guidance Function ---
def mbt_curvature_force(pos):
    r = np.linalg.norm(pos)
    if r == 0:
        return np.zeros(3)
    direction = -pos / r
    curvature_pull = sum([np.exp(-((r - shell_r)**2)) for shell_r in shell_radii])
    return direction * curvature_pull

# --- Visualization Setup ---
fig = plt.figure(figsize=(8, 8))
ax = fig.add_subplot(111, projection='3d')
scat = ax.scatter([], [], [], s=10)

# Draw MBT Curvature Shells (Stable Zones)
u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
for radius in shell_radii:
    x = radius * np.cos(u) * np.sin(v)
    y = radius * np.sin(u) * np.sin(v)
    z = radius * np.cos(v)
    ax.plot_wireframe(x, y, z, color='gray', alpha=0.2)

ax.set_xlim(-10, 10)
ax.set_ylim(-10, 10)
ax.set_zlim(-10, 10)
ax.set_title("MBT: Natural Electron Shell Transitions")

# --- Update Function ---
def update(frame):
    global positions, velocities
    for i in range(num_particles):
        if np.random.rand() < ambient_energy_chance:
            velocities[i] += np.random.randn(3) * energy_boost
        velocities[i] += mbt_curvature_force(positions[i]) * dt
        velocities[i] *= damping_factor
        positions[i] += velocities[i] * dt
    scat._offsets3d = (positions[:, 0], positions[:, 1], positions[:, 2])
    return scat,

# --- Run Animation ---
ani = FuncAnimation(fig, update, frames=steps, interval=50, blit=False)
plt.show()

2. MBT Shells with Central Core (Proton Analogue)

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D

# --- Simulation Parameters ---
num_particles = 20
num_shells = 3
shell_radii = [3 * (i + 1) for i in range(num_shells)]
dt = 0.05
steps = 500
ambient_energy_chance = 0.02
energy_boost = 0.5
damping_factor = 0.98

# --- Central Core Parameters (MBT Nucleus) ---
core_strength = 2.0  # increase for stronger central tension

# --- Initial Particle Setup ---
positions = np.random.randn(num_particles, 3)
positions /= np.linalg.norm(positions, axis=1).reshape(-1, 1)
positions *= np.random.choice(shell_radii, num_particles).reshape(-1, 1)
velocities = np.random.randn(num_particles, 3) * 0.1

# --- MBT Curvature Force (Shells + Core) ---
def mbt_curvature_force(pos):
    r = np.linalg.norm(pos)
    if r == 0:
        return np.zeros(3)
    direction = -pos / r
    shell_force = sum([np.exp(-((r - shell_r)**2)) for shell_r in shell_radii])
    core_force = core_strength / (r**2 + 0.1)  # soft singularity avoidance
    return direction * (shell_force + core_force)

# --- Visualization Setup ---
fig = plt.figure(figsize=(8, 8))
ax = fig.add_subplot(111, projection='3d')
scat = ax.scatter([], [], [], s=10)

# Draw Shells
u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
for radius in shell_radii:
    x = radius * np.cos(u) * np.sin(v)
    y = radius * np.sin(u) * np.sin(v)
    z = radius * np.cos(v)
    ax.plot_wireframe(x, y, z, color='gray', alpha=0.2)

# Mark Core
ax.scatter([0], [0], [0], color='red', s=50, label='Core')

ax.set_xlim(-10, 10)
ax.set_ylim(-10, 10)
ax.set_zlim(-10, 10)
ax.set_title("MBT: Shells with Central Core")

# --- Update Function ---
def update(frame):
    global positions, velocities
    for i in range(num_particles):
        if np.random.rand() < ambient_energy_chance:
            velocities[i] += np.random.randn(3) * energy_boost
        velocities[i] += mbt_curvature_force(positions[i]) * dt
        velocities[i] *= damping_factor
        positions[i] += velocities[i] * dt
    scat._offsets3d = (positions[:, 0], positions[:, 1], positions[:, 2])
    return scat,

# --- Animate ---
ani = FuncAnimation(fig, update, frames=steps, interval=50, blit=False)
plt.legend()
plt.show()

3. MBT Spinning Nucleus + Orbital Shells

# Spinning nucleus version of the MBT model
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D

# --- Parameters ---
num_electrons = 20
num_nucleus_particles = 8
num_shells = 3
trail_length = 50
shell_radii = [3 * (i + 1) for i in range(num_shells)]
dt = 0.05
steps = 500
ambient_energy_chance = 0.02
energy_boost = 0.5
damping_factor = 0.98
core_strength = 2.0
nucleus_spin_rate = 0.05  # radians per frame

# --- Define Rotating Nucleus Points (initial positions) ---
initial_nucleus_points = np.array([
    [1, 1, 1], [-1, 1, 1],
    [1, -1, 1], [-1, -1, 1],
    [1, 1, -1], [-1, 1, -1],
    [1, -1, -1], [-1, -1, -1]
]) * 0.7

# Current positions of nucleus points (will be updated with spin)
nucleus_points = initial_nucleus_points.copy()

# --- Initialize Electron Positions and Velocities ---
positions = np.random.randn(num_electrons, 3)
positions /= np.linalg.norm(positions, axis=1).reshape(-1, 1)
positions *= np.random.choice(shell_radii, num_electrons).reshape(-1, 1)
velocities = np.random.randn(num_electrons, 3) * 0.1
trails = np.zeros((num_electrons, trail_length, 3))

# --- MBT Curvature Force with Rotating Nucleus ---
def mbt_curvature_force(pos):
    r = np.linalg.norm(pos)
    if r == 0:
        return np.zeros(3)
    direction = -pos / r
    shell_force = sum([np.exp(-((r - shell_r)**2)) for shell_r in shell_radii])
    core_force = core_strength / (r**2 + 0.1)

    # Add nucleus influence
    nucleus_pull = np.zeros(3)
    for nuc in nucleus_points:
        diff = pos - nuc
        dist = np.linalg.norm(diff)
        if dist != 0:
            nucleus_pull += -diff / dist * (1.5 / (dist**2 + 0.1))

    return direction * (shell_force + core_force) + nucleus_pull

# --- Visualization Setup ---
fig = plt.figure(figsize=(8, 8))
ax = fig.add_subplot(111, projection='3d')
scat = ax.scatter([], [], [], s=10)
nucleus_scat = ax.scatter([], [], [], color='red', s=50, label='Spinning Nucleus')
lines = [ax.plot([], [], [], lw=1, alpha=0.5)[0] for _ in range(num_electrons)]

# Draw Shells
u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
for radius in shell_radii:
    x = radius * np.cos(u) * np.sin(v)
    y = radius * np.sin(u) * np.sin(v)
    z = radius * np.cos(v)
    ax.plot_wireframe(x, y, z, color='gray', alpha=0.2)

ax.set_xlim(-10, 10)
ax.set_ylim(-10, 10)
ax.set_zlim(-10, 10)
ax.set_title("MBT: Spinning Nucleus + Orbital Shells")

# --- Update Function ---
def update(frame):
    global positions, velocities, trails, nucleus_points

    # Rotate nucleus around Z-axis
    theta = nucleus_spin_rate * frame
    rotation_matrix = np.array([
        [np.cos(theta), -np.sin(theta), 0],
        [np.sin(theta),  np.cos(theta), 0],
        [0, 0, 1]
    ])
    nucleus_points = initial_nucleus_points @ rotation_matrix.T

    for i in range(num_electrons):
        if np.random.rand() < ambient_energy_chance:
            velocities[i] += np.random.randn(3) * energy_boost

        velocities[i] += mbt_curvature_force(positions[i]) * dt
        velocities[i] *= damping_factor
        positions[i] += velocities[i] * dt

        trails[i] = np.roll(trails[i], -1, axis=0)
        trails[i, -1] = positions[i]
        lines[i].set_data(trails[i][:, 0], trails[i][:, 1])
        lines[i].set_3d_properties(trails[i][:, 2])

    scat._offsets3d = (positions[:, 0], positions[:, 1], positions[:, 2])
    nucleus_scat._offsets3d = (nucleus_points[:, 0], nucleus_points[:, 1], nucleus_points[:, 2])
    return [scat, nucleus_scat] + lines

ani = FuncAnimation(fig, update, frames=steps, interval=50, blit=False)
plt.legend()
plt.show()

4. MBT Molecular Structure (Dual Core Bonding)

# Simulate MBT molecular bonding with two fixed nuclei
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D

# Parameters and setup...

# Define two static nuclei
nucleus_template = np.array([...]) * 0.7
nucleus1 = nucleus_template + np.array([4, 0, 0])
nucleus2 = nucleus_template + np.array([-4, 0, 0])
nuclei = np.vstack([nucleus1, nucleus2])

# Initialize electrons...
# Curvature force sums shell + both nuclei...
# Visualization setup...
# Update function for motion, curvature response, and trail updates...
# Run animation...

5. MBT Toroidal Atom (Electron Pairing Zone)

# Simulate toroidal MBT atom with potential pairing behavior
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D

# Parameters
num_electrons = 30
trail_length = 50
dt = 0.05
steps = 500
ambient_energy_chance = 0.02
energy_boost = 0.3
damping_factor = 0.985
core_strength = 2.0

# Toroidal setup
major_radius = 5.0
minor_radius = 1.5

# Electron position and velocity init...
# Toroidal curvature field logic...
# Visualization and animation logic...

6. MBT Toroidal Atom with Shell Jumps (Excitation/Decay)

# MBT Toroidal Atom with Shell Jump Detection and Return
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from mpl_toolkits.mplot3d import Axes3D

# Parameters: 30 electrons, energy injection, damping, curvature
# Toroidal motion generated with stable shell (major + minor radius)

# Electrons randomly get excited (orange) and jump out of stable curvature zone
# If they return to within threshold, they're considered re-stabilized (blue)

# Update function checks shell distance and flips visual state
# No quantum mechanics needed â€” only curvature and motion resistance

# This system simulates natural MBT transitions: excitation, decay, reintegration
