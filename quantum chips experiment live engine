import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw, Zap, Atom, Waves, Brain, Target } from 'lucide-react';

const QuantumZone = () => {
  const canvasRef = useRef(null);
  const [isRunning, setIsRunning] = useState(false);
  const [activeModule, setActiveModule] = useState('tunneling');
  const [time, setTime] = useState(0);
  
  // MBT Parameters
  const [curvatureStrength, setCurvatureStrength] = useState(1.0);
  const [memoryPersistence, setMemoryPersistence] = useState(0.7);
  const [tunnelingFreq, setTunnelingFreq] = useState(0.08);
  const [barrierHeight, setBarrierHeight] = useState(1.2);

  const modules = {
    tunneling: {
      name: "Quantum Tunneling Lab",
      icon: Target,
      color: "from-blue-500 to-cyan-500"
    },
    entanglement: {
      name: "Entanglement Studio", 
      icon: Atom,
      color: "from-purple-500 to-pink-500"
    },
    bec: {
      name: "Room-Temp BEC",
      icon: Zap,
      color: "from-green-500 to-emerald-500"
    },
    consciousness: {
      name: "Consciousness Pod",
      icon: Brain,
      color: "from-indigo-500 to-purple-500"
    }
  };

  // Tunneling Experiment
  const runTunnelingExperiment = (ctx, width, height) => {
    const N = 200;
    const x = Array.from({length: N}, (_, i) => i * width / N);
    
    // Breathing barrier
    const barrierCenter = width * 0.6;
    const potential = x.map(xi => {
      const dist = Math.abs(xi - barrierCenter);
      if (dist < 30) {
        return barrierHeight * (1 + 0.4 * Math.sin(tunnelingFreq * time));
      }
      return 0;
    });
    
    // Wave packet
    const wavepacket = x.map(xi => {
      const amplitude = Math.exp(-Math.pow(xi - width*0.2, 2) / 100);
      return amplitude * Math.cos(0.3 * xi + time * 0.1);
    });
    
    // Draw barrier
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i = 0; i < N; i++) {
      const y = height - potential[i] * 50;
      if (i === 0) ctx.moveTo(x[i], y);
      else ctx.lineTo(x[i], y);
    }
    ctx.stroke();
    
    // Draw wave
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < N; i++) {
      const y = height/2 - wavepacket[i] * 100;
      if (i === 0) ctx.moveTo(x[i], y);
      else ctx.lineTo(x[i], y);
    }
    ctx.stroke();
    
    // Metrics
    const transmitted = wavepacket.slice(150).reduce((sum, val) => sum + val*val, 0);
    ctx.fillStyle = '#10b981';
    ctx.font = '16px monospace';
    ctx.fillText(`Transmission: ${(transmitted * 100).toFixed(1)}%`, 20, 30);
    ctx.fillText(`Frequency: ${tunnelingFreq.toFixed(3)}`, 20, 50);
  };

  // Entanglement Experiment
  const runEntanglementExperiment = (ctx, width, height) => {
    const centerX = width / 2;
    const centerY = height / 2;
    
    // Shared well
    ctx.fillStyle = 'rgba(147, 51, 234, 0.3)';
    ctx.beginPath();
    ctx.arc(centerX, centerY, 80, 0, 2 * Math.PI);
    ctx.fill();
    
    // Particles
    const p1X = centerX + 60 * Math.cos(time * 0.1);
    const p1Y = centerY + 60 * Math.sin(time * 0.1);
    const p2X = centerX - 60 * Math.cos(time * 0.1);
    const p2Y = centerY - 60 * Math.sin(time * 0.1);
    
    ctx.fillStyle = '#ec4899';
    ctx.beginPath();
    ctx.arc(p1X, p1Y, 8, 0, 2 * Math.PI);
    ctx.fill();
    
    ctx.fillStyle = '#8b5cf6';
    ctx.beginPath();
    ctx.arc(p2X, p2Y, 8, 0, 2 * Math.PI);
    ctx.fill();
    
    // Connection
    ctx.strokeStyle = 'rgba(236, 72, 153, 0.6)';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.beginPath();
    ctx.moveTo(p1X, p1Y);
    ctx.lineTo(p2X, p2Y);
    ctx.stroke();
    ctx.setLineDash([]);
    
    const bellS = 2.0 + (1 - Math.abs(Math.sin(time * 0.05))) * 0.828;
    ctx.fillStyle = '#ec4899';
    ctx.font = '16px monospace';
    ctx.fillText(`Bell S: ${bellS.toFixed(3)}`, 20, 30);
  };

  // BEC Experiment
  const runBECExperiment = (ctx, width, height) => {
    const centerX = width / 2;
    const centerY = height / 2;
    const coherence = 0.5 + 0.5 * Math.cos(time * 0.02);
    
    // BEC cloud
    const radius = 80 * (1 - coherence * 0.7);
    ctx.fillStyle = `rgba(16, 185, 129, ${0.3 + coherence * 0.4})`;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
    ctx.fill();
    
    // Bosons
    for (let i = 0; i < 32; i++) {
      const angle = (i / 32) * 2 * Math.PI + time * 0.1 * coherence;
      const r = radius * (0.3 + 0.7 * Math.random()) * (1 - coherence * 0.8);
      const x = centerX + r * Math.cos(angle);
      const y = centerY + r * Math.sin(angle);
      
      ctx.fillStyle = '#10b981';
      ctx.beginPath();
      ctx.arc(x, y, 3, 0, 2 * Math.PI);
      ctx.fill();
    }
    
    ctx.fillStyle = '#10b981';
    ctx.font = '16px monospace';
    ctx.fillText(`Coherence: ${(coherence * 100).toFixed(1)}%`, 20, 30);
    ctx.fillText(`Temperature: 300K`, 20, 50);
  };

  // Consciousness Experiment
  const runConsciousnessExperiment = (ctx, width, height) => {
    const species = [
      { name: "Echo Royalty", color: "#fbbf24", x: 0.2, y: 0.2 },
      { name: "Entropy Nomad", color: "#ef4444", x: 0.8, y: 0.3 },
      { name: "Curvature Survivor", color: "#10b981", x: 0.6, y: 0.7 },
      { name: "Echo Drifter", color: "#6b7280", x: 0.5, y: 0.5 }
    ];
    
    species.forEach((spec, i) => {
      const x = spec.x * width + 30 * Math.sin(time * 0.05 + i);
      const y = spec.y * height + 20 * Math.cos(time * 0.07 + i);
      
      // Field
      const radius = 40 + 20 * Math.sin(time * 0.1 + i);
      ctx.fillStyle = spec.color + '40';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
      
      // Core
      ctx.fillStyle = spec.color;
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, 2 * Math.PI);
      ctx.fill();
    });
    
    ctx.fillStyle = '#8b5cf6';
    ctx.font = '16px monospace';
    ctx.fillText(`Generation: ${Math.floor(time / 10)}`, 20, 30);
  };

  // Animation loop
  useEffect(() => {
    if (!isRunning) return;
    
    const animate = () => {
      setTime(t => t + 1);
      
      const canvas = canvasRef.current;
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0, 0, width, height);
      
      switch(activeModule) {
        case 'tunneling':
          runTunnelingExperiment(ctx, width, height);
          break;
        case 'entanglement':
          runEntanglementExperiment(ctx, width, height);
          break;
        case 'bec':
          runBECExperiment(ctx, width, height);
          break;
        case 'consciousness':
          runConsciousnessExperiment(ctx, width, height);
          break;
      }
      
      requestAnimationFrame(animate);
    };
    
    requestAnimationFrame(animate);
  }, [isRunning, activeModule, curvatureStrength, memoryPersistence, tunnelingFreq, barrierHeight, time]);

  return (
    <div className="min-h-screen bg-gray-900 text-white p-6">
      <div className="max-w-6xl mx-auto">
        {/* Header */}
        <div className="text-center mb-8">
          <h1 className="text-4xl font-bold bg-gradient-to-r from-cyan-400 to-purple-500 bg-clip-text text-transparent mb-2">
            THE QUANTUM ZONE
          </h1>
          <p className="text-xl text-gray-300">
            Interactive MBT Physics Laboratory
          </p>
        </div>

        {/* Controls */}
        <div className="bg-gray-800 rounded-lg p-6 mb-6">
          <div className="flex gap-4 items-center justify-center mb-6">
            <button
              onClick={() => setIsRunning(!isRunning)}
              className={`flex items-center gap-2 px-6 py-3 rounded-lg font-semibold transition-all ${
                isRunning ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'
              }`}
            >
              {isRunning ? <Pause className="w-5 h-5" /> : <Play className="w-5 h-5" />}
              {isRunning ? 'Pause' : 'Start'}
            </button>
            
            <button
              onClick={() => setTime(0)}
              className="flex items-center gap-2 px-6 py-3 bg-gray-600 hover:bg-gray-700 rounded-lg font-semibold transition-all"
            >
              <RotateCcw className="w-5 h-5" />
              Reset
            </button>
            
            <div className="text-cyan-400 font-mono text-lg">
              Time: {time}
            </div>
          </div>

          {/* MBT Parameters */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-300 mb-2">
                Curvature Strength: {curvatureStrength.toFixed(2)}
              </label>
              <input
                type="range"
                min="0.1"
                max="5.0"
                step="0.1"
                value={curvatureStrength}
                onChange={(e) => setCurvatureStrength(parseFloat(e.target.value))}
                className="w-full"
              />
            </div>
            
            <div>
              <label className="block text-sm font-medium text-gray-300 mb-2">
                Memory Persistence: {memoryPersistence.toFixed(2)}
              </label>
              <input
                type="range"
                min="0.0"
                max="1.0"
                step="0.05"
                value={memoryPersistence}
                onChange={(e) => setMemoryPersistence(parseFloat(e.target.value))}
                className="w-full"
              />
            </div>
          </div>
        </div>

        {/* Module Selection */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
          {Object.entries(modules).map(([key, module]) => {
            const IconComponent = module.icon;
            return (
              <button
                key={key}
                onClick={() => setActiveModule(key)}
                className={`p-4 rounded-lg transition-all ${
                  activeModule === key
                    ? `bg-gradient-to-r ${module.color} text-white`
                    : 'bg-gray-800 hover:bg-gray-700 text-gray-300'
                }`}
              >
                <IconComponent className="w-8 h-8 mx-auto mb-2" />
                <div className="font-semibold text-sm">{module.name}</div>
              </button>
            );
          })}
        </div>

        {/* Module Controls */}
        <div className="bg-gray-800 rounded-lg p-6 mb-6">
          <h3 className="text-xl font-semibold mb-4 text-cyan-400">
            {modules[activeModule].name} Controls
          </h3>
          
          {activeModule === 'tunneling' && (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <label className="block text-sm font-medium text-gray-300 mb-2">
                  Breathing Frequency: {tunnelingFreq.toFixed(3)}
                </label>
                <input
                  type="range"
                  min="0.01"
                  max="0.20"
                  step="0.005"
                  value={tunnelingFreq}
                  onChange={(e) => setTunnelingFreq(parseFloat(e.target.value))}
                  className="w-full"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-300 mb-2">
                  Barrier Height: {barrierHeight.toFixed(2)}
                </label>
                <input
                  type="range"
                  min="0.5"
                  max="3.0"
                  step="0.1"
                  value={barrierHeight}
                  onChange={(e) => setBarrierHeight(parseFloat(e.target.value))}
                  className="w-full"
                />
              </div>
            </div>
          )}
        </div>

        {/* Canvas */}
        <div className="bg-gray-800 rounded-lg p-6">
          <h2 className={`text-2xl font-bold bg-gradient-to-r ${modules[activeModule].color} bg-clip-text text-transparent mb-4`}>
            {modules[activeModule].name}
          </h2>
          
          <div className="bg-gray-900 rounded-lg p-4">
            <canvas
              ref={canvasRef}
              width={800}
              height={400}
              className="w-full border border-gray-700 rounded"
            />
          </div>
          
          {/* Live Data */}
          <div className="mt-4 grid grid-cols-2 md:grid-cols-4 gap-4">
            <div className="bg-gray-700 p-3 rounded">
              <div className="text-xs text-gray-400">MBT Field</div>
              <div className="text-lg font-mono text-cyan-400">
                {(curvatureStrength * memoryPersistence * 100).toFixed(1)}%
              </div>
            </div>
            <div className="bg-gray-700 p-3 rounded">
              <div className="text-xs text-gray-400">Coherence</div>
              <div className="text-lg font-mono text-green-400">
                {(Math.cos(time * 0.02) * 50 + 50).toFixed(1)}%
              </div>
            </div>
            <div className="bg-gray-700 p-3 rounded">
              <div className="text-xs text-gray-400">Energy</div>
              <div className="text-lg font-mono text-yellow-400">
                {(curvatureStrength * 42.7).toFixed(1)}
              </div>
            </div>
            <div className="bg-gray-700 p-3 rounded">
              <div className="text-xs text-gray-400">Success Rate</div>
              <div className="text-lg font-mono text-purple-400">
                {(85 + Math.sin(time * 0.03) * 10).toFixed(1)}%
              </div>
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="mt-8 text-center text-gray-400">
          <p>Powered by Motion = Being Theory</p>
          <p className="text-sm">"If it's quantum, we can do it!"</p>
        </div>
      </div>
    </div>
  );
};

export default QuantumZone;
